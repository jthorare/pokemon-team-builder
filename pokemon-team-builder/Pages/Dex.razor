@page "/pokedex"
@using pokemon_team_builder.Components
@using pokemon_team_builder.PokemonCommon
@using pokemon_team_builder.Services
@inject PokeApiService pokeService
@inject NavigationManager UriHelper

<h3>Pokedex</h3>

<Div>
    <Blazorise.Components.Autocomplete Class="mb-2" TItem="PokemonEntry" TValue="PokemonEntry" Data="@PokemonInDex"
                                       TextField="@((item) => item.PokemonSpecies.Name)" ValueField="@((item) => item)" Placeholder="Search ..."
                                       Filter="Blazorise.Components.AutocompleteFilter.StartsWith"
                                       SearchChanged=@SearchForMatchingPokemon>
        <NotFoundContent> Sorry ... @context was not found.</NotFoundContent>
    </Blazorise.Components.Autocomplete>

    <Div>

        <Div>
            <Label Class="me-1 label-shift-up">Type 1: </Label>
            <RadzenDropDown TValue="string" Data=@Types1 Placeholder="Choose a type" AllowClear="true" AllowFiltering="true" SelectedItemsText=@Type2 Change=@(async (args) => await TypeFilterChanged(args, false)) />
            <Label>Type 2: </Label>
            <RadzenDropDown TValue="string" Data=@Types2 Placeholder="Choose a type" AllowClear="true" AllowFiltering="true" SelectedItemsText=@Type2 Change=@(async (args) => await TypeFilterChanged(args, true)) />
        </Div>
    </Div>
</Div>

<Div>
    @foreach (PokemonEntry pokemon in PokemonInDex)
    {
        <Button Clicked=@(() => NavigateToPokemon(pokemon))>
            <PokemonComponent NatDexId=@PokemonUtilities.GetNatDexId(pokemon.PokemonSpecies.Url)/>
        </Button>
    }
</Div>

@code {
    private string Type1 { get; set; } = "";
    private string Type2 { get; set; } = "";
    private IEnumerable<string> Types { get; set; } = PokeApiConstants.TypeMappings.Keys.ToList();
    private IEnumerable<string> Types1 { get; set; } = PokeApiConstants.TypeMappings.Keys.ToList();
    private IEnumerable<string> Types2 { get; set; } = PokeApiConstants.TypeMappings.Keys.ToList();

    List<PokemonEntry> PokemonInDex { get; set; } = new();
    List<PokemonEntry> NationalDex { get; set; } = new();

    /// <summary>
    /// Populates the displayed dex and the cached NationalDex.
    /// </summary>
    /// <returns>A Task for async purposes.</returns>
    protected override async Task OnInitializedAsync()
    {
        Pokedex pokedex = await pokeService.GetPokedex("national");
        PokemonInDex.AddRange(pokedex.PokemonEntries);
        NationalDex = pokedex.PokemonEntries;
    }

    /// <summary>
    /// Navigates to the page for the selected pokemon.
    /// </summary>
    /// <param name="pokemon">The pokemon we want to see the page for.</param>
    private void NavigateToPokemon(PokemonEntry pokemon)
    {
        UriHelper.NavigateTo($"pokemon?pokemon={PokemonUtilities.GetNatDexId(pokemon.PokemonSpecies.Url)}");
    }


    /// <summary>
    /// Searches for all pokemon whose names start with the given string.
    /// </summary>
    /// <param name="args">The pokemon's name as an object.</param>
    private void SearchForMatchingPokemon(object args)
    {
        if (args is not null)
        {
            string name = (string)args;
            PokemonInDex = NationalDex.Where(pokemon => pokemon.PokemonSpecies.Name.Contains(name)).ToList();
        }
    }

    /// <summary>
    /// Sets the corresponding Type# property.
    /// </summary>
    /// <param name="type">The string to set the Type# to.</param>
    /// <param name="two">Are we changing the Type2 property.</param>
    private void ChangeType(string type, bool two)
    {
        if (!two)
        {
            Type1 = type;
        }
        if (two)
        {
            Type2 = type;
        }
    }

    /// <summary>
    /// Event handler for the Type Filters.
    /// </summary>
    /// <param name="args">The type (string) as an object.</param>
    /// <param name="two">Is this firing because it is for Type2?</param>
    /// <returns>Task for async purposes.</returns>
    private async Task TypeFilterChanged(object args, bool two)
    {
        if (args is not null)
        {
            string type = (string)args;
            ChangeType(type, two);
        }
        if (args is null) // this event gets fired by clearing the dropdowns
        {
            ChangeType("", two);
        }

        //  get the Type that isn't null, refilter
        PokemonInDex = await FilterDex();
        Types1 = Types.Where(type => type != Type2);
        Types2 = Types.Where(type => type != Type1);

        StateHasChanged();
    }

    /// <summary>
    /// Filters the National Dex by the Type1 and Type2 properties.
    /// </summary>
    /// <returns>The pokemon of the correct types.</returns>
    private async Task<List<PokemonEntry>> FilterDex()
    {
        HashSet<string> pokemonOfType1;
        HashSet<string> pokemonOfType2;
        if (String.IsNullOrEmpty(Type1)) // if there is no filter, default to all pokemon
        {
            pokemonOfType1 = NationalDex.Select(x => x.PokemonSpecies.Name).ToHashSet();
        }
        else
        {
            pokemonOfType1 = await pokeService.GetPokemonOfType(Type1); // get the pokemon of that type
        }
        if (String.IsNullOrEmpty(Type2)) // if there is no filter, default to all pokemon

        {
            pokemonOfType2 = NationalDex.Select(x => x.PokemonSpecies.Name).ToHashSet();
        }
        else
        {
            pokemonOfType2 = await pokeService.GetPokemonOfType(Type2); // get the pokemon of that type
        }
        HashSet<string> pokemonOfBothTypes = pokemonOfType1.Where(pokemon => pokemonOfType2.Contains(pokemon)).ToHashSet();
        return NationalDex.Where(pokemon => pokemonOfBothTypes.Contains(pokemon.PokemonSpecies.Name)).ToList();
    }
}